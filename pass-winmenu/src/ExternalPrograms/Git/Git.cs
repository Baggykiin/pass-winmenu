using System;
using System.Linq;
using LibGit2Sharp;

namespace PassWinmenu.ExternalPrograms
{
	/// <inheritdoc cref="IDisposable" />
	/// <summary>
	/// Simple wrapper over git.
	/// </summary>
	internal class Git : IDisposable, ISyncService
	{
		private readonly IRepository repo;
		private readonly IGitSyncStrategy gitSyncStrategy;

		/// <summary>
		/// Initialises the wrapper.
		/// </summary>
		/// <param name="repo">The repository git should operate on.</param>
		/// <param name="gitSyncStrategy">The strategy to use for synchronising repository changes.</param>
		public Git(IRepository repo, IGitSyncStrategy gitSyncStrategy)
		{
			this.repo = repo;
			this.gitSyncStrategy = gitSyncStrategy;
		}

		public BranchTrackingDetails GetTrackingDetails() => repo.Head.TrackingDetails;

		/// <summary>
		/// Rebases the current branch onto the branch it is tracking.
		/// </summary>
		public void Rebase()
		{
			var head = repo.Head;
			var tracked = head.TrackedBranch;

			var sig = BuildSignature();

			var result = repo.Rebase.Start(head, tracked, null, new Identity(sig.Name, sig.Email), new RebaseOptions());
			if (result.Status != RebaseStatus.Complete)
			{
				repo.Rebase.Abort();
				throw new GitException($"Could not rebase {head.FriendlyName} onto {head.TrackedBranch.FriendlyName}");
			}
			else if (result.CompletedStepCount > 0)
			{
				// One or more commits were rebased
			}
			else
			{
				// Fast-forward or no upstream changes
			}
		}

		public void Fetch()
		{
			gitSyncStrategy.Fetch(repo.Head);
		}

		public void Push()
		{
			gitSyncStrategy.Push();
		}

		public RepositoryStatus Commit()
		{
			UnstageAll();

			var status = repo.RetrieveStatus();
			var filesToCommit = status.Where(f => f.State != FileStatus.Ignored);

			foreach (var entry in filesToCommit)
			{
				Commands.Stage(repo, entry.FilePath);
				var sig = repo.Config.BuildSignature(DateTimeOffset.Now);
				repo.Commit($"{GetVerbFromGitFileStatus(entry.State)} password store file {entry.FilePath}\n\n" +
							"This commit was automatically generated by pass-winmenu.", sig, sig);
			}

			return status;
		}

		public void EditPassword(string passwordFilePath)
		{
			var status = repo.RetrieveStatus(passwordFilePath);
			if (status == FileStatus.ModifiedInWorkdir)
			{
				Commands.Stage(repo, passwordFilePath);
				var sig = BuildSignature();
				repo.Commit($"Edit password file {passwordFilePath}\n\n" +
							"This commit was automatically generated by pass-winmenu.", sig, sig);
			}
		}

		public void AddPassword(string passwordFilePath)
		{
			var status = repo.RetrieveStatus(passwordFilePath);
			if (status == FileStatus.NewInWorkdir)
			{
				Commands.Stage(repo, passwordFilePath);
				var sig = BuildSignature();
				repo.Commit($"Add password file {passwordFilePath}\n\n" +
							"This commit was automatically generated by pass-winmenu.", sig, sig);
			}
		}

		public void Dispose()
		{
			repo?.Dispose();
		}

		private string GetVerbFromGitFileStatus(FileStatus status)
		{
			switch (status)
			{
				case FileStatus.DeletedFromWorkdir:
					return "Delete";
				case FileStatus.NewInWorkdir:
					return "Add";
				case FileStatus.ModifiedInWorkdir:
					return "Modify";
				case FileStatus.RenamedInWorkdir:
					return "Rename";
				case FileStatus.TypeChangeInWorkdir:
					return "Change filetype for";
				default:
					throw new ArgumentException(nameof(status));
			}
		}

		private void UnstageAll()
		{
			var status = repo.RetrieveStatus();
			var staged = status.Where(e => (e.State
			                              & (FileStatus.DeletedFromIndex
			                               | FileStatus.ModifiedInIndex
			                               | FileStatus.NewInIndex
			                               | FileStatus.RenamedInIndex
			                               | FileStatus.TypeChangeInIndex)) > 0)
			                   .ToList();
			if (staged.Any())
			{
				Commands.Unstage(repo, staged.Select(entry => entry.FilePath));
			}
		}

		private Signature BuildSignature()
		{
			var sig = repo.Config.BuildSignature(DateTimeOffset.Now);
			if (sig == null)
			{
				throw new GitException("Could not build Git signature. Make sure 'user.name' and 'user.email' are configured for the repository.");
			}
			return sig;
		}
	}
}
