using System;
using System.IO;
using System.Linq;
using LibGit2Sharp;
using PassWinmenu.Configuration;

namespace PassWinmenu.ExternalPrograms
{
	/// <summary>
	/// Simple wrapper over git.
	/// </summary>
	internal class Git : IDisposable
	{
		private readonly Repository repo;
		private readonly FetchOptions fetchOptions;
		private readonly PushOptions pushOptions;

		/// <summary>
		/// Initialises the wrapper.
		/// </summary>
		/// <param name="repositoryPath">The repository git should operate on.</param>
		public Git(string repositoryPath)
		{
			repo = new Repository(repositoryPath);
			fetchOptions = new FetchOptions();
			pushOptions = new PushOptions();

			// Only use the SSH credentials provider if the remote URL is an SSH url.
			// If it's not, we're better off letting libgit figure out how to deal with it.
			var uri = new Uri(repo.Network.Remotes[repo.Head.RemoteName].Url);
			if (uri.Scheme == "ssh")
			{
				fetchOptions.CredentialsProvider = SshCredentialsProvider;
				pushOptions.CredentialsProvider = SshCredentialsProvider;
			}
		}

		private Signature BuildSignature() => repo.Config.BuildSignature(DateTimeOffset.Now);

		public void Rebase()
		{
			var head = repo.Head;
			var remote = repo.Network.Remotes[head.RemoteName];

			// First, fetch the latest version from the remote being tracked by the current branch


			Commands.Fetch(repo, head.RemoteName, remote.FetchRefSpecs.Select(rs => rs.Specification), fetchOptions, null);

			var tracked = head.TrackedBranch;
			var sig = BuildSignature();
			var result = repo.Rebase.Start(head, tracked, null, new Identity(sig.Name, sig.Email), new RebaseOptions());
			if (result.Status != RebaseStatus.Complete)
			{
				repo.Rebase.Abort();
				throw new InvalidOperationException($"Could not rebase {head.FriendlyName} onto {head.TrackedBranch.FriendlyName}");
			}
			else if (result.CompletedStepCount > 0)
			{
				// One or more commits were rebased
			}
			else
			{
				// Fast-forward or no upstream changes
			}
		}

		/// <summary>
		/// Pushes changes to remote.
		/// </summary>
		public void Update()
		{
			repo.Network.Push(repo.Head, pushOptions);
		}

		private static Credentials SshCredentialsProvider(string url, string usernameFromUrl, SupportedCredentialTypes types)
		{
			if (types != SupportedCredentialTypes.Ssh)
			{
				throw new InvalidOperationException("Cannot use the SSH credentials provider for non-SSH protocols.");
			}

			var searchLocations = ConfigManager.Config.SshKeySearchLocations;

			foreach (var location in searchLocations)
			{
				var privateKey = Path.Combine(location, "id_rsa");
				var publicKey = Path.Combine(location, "id_rsa.pub");

				if (File.Exists(privateKey) && File.Exists(publicKey))
				{
					var sshUserKeyCredentials = new SshUserKeyCredentials
					{
						PrivateKey = Path.Combine(location, "id_rsa"),
						PublicKey = Path.Combine(location, "id_rsa.pub"),
						Username = usernameFromUrl,
						Passphrase = ""
					};
					return sshUserKeyCredentials;
				}
			}
			return null;
		}

		public RepositoryStatus Commit()
		{
			var status = repo.RetrieveStatus();
			var staged = status.Where(e => (e.State
											& (FileStatus.DeletedFromIndex
											   | FileStatus.ModifiedInIndex
											   | FileStatus.NewInIndex
											   | FileStatus.RenamedInIndex
											   | FileStatus.TypeChangeInIndex)) > 0)
											   .ToList();
			if (staged.Any())
			{
				Commands.Unstage(repo, staged.Select(entry => entry.FilePath));
			}

			var filesToCommit = repo.RetrieveStatus();

			foreach (var entry in filesToCommit)
			{
				Commands.Stage(repo, entry.FilePath);
				var sig = repo.Config.BuildSignature(DateTimeOffset.Now);
				repo.Commit($"{GetVerbFromGitFileStatus(entry.State)} password store file {entry.FilePath}\n\n" +
							$"This commit was automatically generated by pass-winmenu.", sig, sig);
			}

			return filesToCommit;
		}

		private string GetVerbFromGitFileStatus(FileStatus status)
		{
			switch (status)
			{
				case FileStatus.DeletedFromWorkdir:
					return "Delete";
				case FileStatus.NewInWorkdir:
					return "Add";
				case FileStatus.ModifiedInWorkdir:
					return "Modify";
				case FileStatus.RenamedInWorkdir:
					return "Rename";
				case FileStatus.TypeChangeInWorkdir:
					return "Change filetype for";
				default:
					throw new ArgumentException(nameof(status));
			}
		}

		public void EditPassword(string passwordFilePath)
		{
			var status = repo.RetrieveStatus(passwordFilePath);
			if (status == FileStatus.ModifiedInWorkdir)
			{
				Commands.Stage(repo, passwordFilePath);
				var sig = BuildSignature();
				repo.Commit($"Edit password file {passwordFilePath}\n\n" +
							$"This commit was automatically generated by pass-winmenu.", sig, sig);
			}
		}

		public void AddPassword(string passwordFilePath)
		{
			var status = repo.RetrieveStatus(passwordFilePath);
			if (status == FileStatus.NewInWorkdir)
			{
				Commands.Stage(repo, passwordFilePath);
				var sig = BuildSignature();
				repo.Commit($"Add password file {passwordFilePath}\n\n" +
							$"This commit was automatically generated by pass-winmenu.", sig, sig);
			}
		}

		public void Dispose()
		{
			repo?.Dispose();
		}
	}
}
