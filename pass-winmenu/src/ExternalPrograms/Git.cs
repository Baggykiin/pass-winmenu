using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using LibGit2Sharp;
using PassWinmenu.Configuration;
using PassWinmenu.Utilities;

namespace PassWinmenu.ExternalPrograms
{
	/// <summary>
	/// Simple wrapper over git.
	/// </summary>
	internal class Git
	{
		private readonly Repository repo;

		/// <summary>
		/// Initialises the wrapper.
		/// </summary>
		/// <param name="repositoryPath">The repository git should operate on.</param>
		public Git(string repositoryPath)
		{
			repo = new Repository(repositoryPath);
		}

		private Signature BuildSignature() => repo.Config.BuildSignature(DateTimeOffset.Now);

		public void Rebase()
		{
			var head = repo.Head;
			var remote = repo.Network.Remotes[head.RemoteName];

			// First, fetch the latest version from the remote being tracked by the current branch
			Commands.Fetch(repo, head.RemoteName, remote.FetchRefSpecs.Select(rs => rs.Specification), new FetchOptions
			{
				CredentialsProvider = GitCredentialsProvider
			}, null);

			var tracked = head.TrackedBranch;
			var sig = BuildSignature();
			var result = repo.Rebase.Start(head, tracked, null, new Identity(sig.Name, sig.Email), new RebaseOptions());
			if (result.Status != RebaseStatus.Complete)
			{
				repo.Rebase.Abort();
				throw new InvalidOperationException($"Could not rebase {head.FriendlyName} onto {head.TrackedBranch.FriendlyName}");
			}
			else if (result.CompletedStepCount > 0)
			{
				// One or more commits were rebased
			}
			else
			{
				// Fast-forward or no upstream changes
			}
		}

		/// <summary>
		/// Pushes changes to remote.
		/// </summary>
		public void Update()
		{
			repo.Network.Push(repo.Head, new PushOptions
			{
				CredentialsProvider = GitCredentialsProvider
			});
		}

		private Credentials GitCredentialsProvider(string url, string usernameFromUrl, SupportedCredentialTypes types)
		{
			// TODO: Handle only SSH credentials in this method
			switch (types)
			{
				case SupportedCredentialTypes.UsernamePassword:
					break;
				case SupportedCredentialTypes.Default:
					break;
				case SupportedCredentialTypes.Ssh:
					return GetSshCredentials(usernameFromUrl);
				case SupportedCredentialTypes.UsernameQuery:
					break;
				default:
					throw new ArgumentOutOfRangeException(nameof(types), types, null);
			}
			throw new NotImplementedException($"Unsupported credential type {types}");
		}
		private Credentials GetSshCredentials(string username)
		{
			var searchLocations = ConfigManager.Config.SshKeySearchLocations;

			foreach (var location in searchLocations)
			{
				// TODO: Search for credentials
				var sshUserKeyCredentials = new SshUserKeyCredentials
				{
					PrivateKey = Path.Combine(location, "id_rsa"),
					PublicKey = Path.Combine(location, "id_rsa.pub"),
					Username = username,
					Passphrase = ""
				};
				return sshUserKeyCredentials;
			}
			return null;
		}

		public RepositoryStatus Commit()
		{
			var status = repo.RetrieveStatus();
			var staged = status.Where(e => (e.State
											& (FileStatus.DeletedFromIndex
											   | FileStatus.ModifiedInIndex
											   | FileStatus.NewInIndex
											   | FileStatus.RenamedInIndex
											   | FileStatus.TypeChangeInIndex)) > 0)
											   .ToList();
			if (staged.Any())
			{
				Commands.Unstage(repo, staged.Select(entry => entry.FilePath));
			}

			var filesToCommit = repo.RetrieveStatus();

			foreach (var entry in filesToCommit)
			{
				Commands.Stage(repo, entry.FilePath);
				var sig = repo.Config.BuildSignature(DateTimeOffset.Now);
				repo.Commit($"{GetVerbFromGitFileStatus(entry.State)} password store file {entry.FilePath}\n\n" +
							$"This commit was automatically generated by pass-winmenu.", sig, sig);
			}

			return filesToCommit;
		}

		private string GetVerbFromGitFileStatus(FileStatus status)
		{
			switch (status)
			{
				case FileStatus.DeletedFromWorkdir:
					return "Delete";
				case FileStatus.NewInWorkdir:
					return "Add";
				case FileStatus.ModifiedInWorkdir:
					return "Modify";
				case FileStatus.RenamedInWorkdir:
					return "Rename";
				case FileStatus.TypeChangeInWorkdir:
					return "Change filetype for";
				default:
					throw new ArgumentException(nameof(status));
			}
		}

		public void EditPassword(string passwordFilePath)
		{
			var status = repo.RetrieveStatus(passwordFilePath);
			if (status == FileStatus.ModifiedInWorkdir)
			{
				Commands.Stage(repo, passwordFilePath);
				var sig = BuildSignature();
				repo.Commit($"Edit password file {passwordFilePath}\n\n" +
							$"This commit was automatically generated by pass-winmenu.", sig, sig);
			}
		}

		public void AddPassword(string passwordFilePath)
		{
			var status = repo.RetrieveStatus(passwordFilePath);
			if (status == FileStatus.NewInWorkdir)
			{
				Commands.Stage(repo, passwordFilePath);
				var sig = BuildSignature();
				repo.Commit($"Add password file {passwordFilePath}\n\n" +
							$"This commit was automatically generated by pass-winmenu.", sig, sig);
			}
		}
	}
}
